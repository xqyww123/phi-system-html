<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><link rel="stylesheet" type="text/css" href="isabelle.css"/>
<title>Theory Scratch</title>
</head>


<body>
<div class="head">
<h1>Theory Scratch</h1>
</div>

<pre class="source"><span class="keyword1"><span class="command"><span>theory</span></span></span><span> </span><a href="Scratch.html"><span>Scratch</span></a><span>
  </span><span class="keyword2"><span class="keyword"><span>imports</span></span></span><span> </span><a href="../../HOL/HOL/Main.html"><span>Main</span></a><span>
</span><span class="keyword2"><span class="keyword"><span>begin</span></span></span><span>


</span><span class="keyword1"><span class="command"><span>text</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‹

</span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>{A<span class="hidden">⇩</span><sub>1</sub>, A<span class="hidden">⇩</span><sub>2</sub>, …, C} ⟷ A<span class="hidden">⇩</span><sub>1</sub> ∧ A<span class="hidden">⇩</span><sub>2</sub> ∧ … ∧ C›</span></span></span><span>

Propostional Logic:

assertion (judgement): </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>P<span class="hidden">⇩</span><sub>1</sub>, P<span class="hidden">⇩</span><sub>2</sub>, …, P<span class="hidden">⇩</span><sub>n</sub> ⊢ C›</span></span></span><span>, meaning from the hypotheses of </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>P<span class="hidden">⇩</span><sub>1</sub>, P<span class="hidden">⇩</span><sub>2</sub>, …, P<span class="hidden">⇩</span><sub>n</sub>›</span></span></span><span>,
                                                     we can deduce conclusion </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>A›</span></span></span><span>
  </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>P<span class="hidden">⇩</span><sub>1</sub> ∧ P<span class="hidden">⇩</span><sub>2</sub> ∧ … ∧ P<span class="hidden">⇩</span><sub>n</sub> ⟶ C ›</span></span></span><span>

</span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>
  P ⊢ A ∧ B 
----------------
   P ⊢ A
›</span></span></span><span>

Sequent Calculus,

assertion </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>P<span class="hidden">⇩</span><sub>1</sub>, P<span class="hidden">⇩</span><sub>2</sub>, …, P<span class="hidden">⇩</span><sub>n</sub> ⇒ C<span class="hidden">⇩</span><sub>1</sub>, C<span class="hidden">⇩</span><sub>2</sub>, …, C<span class="hidden">⇩</span><sub>m</sub>›</span></span></span><span>, meaning
  from the hypotheses of </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>P<span class="hidden">⇩</span><sub>1</sub>, P<span class="hidden">⇩</span><sub>2</sub>, …, P<span class="hidden">⇩</span><sub>n</sub>›</span></span></span><span>, we can deduce one of the </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>C<span class="hidden">⇩</span><sub>1</sub>, C<span class="hidden">⇩</span><sub>2</sub>, …, C<span class="hidden">⇩</span><sub>m</sub>›</span></span></span><span>

  </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>P<span class="hidden">⇩</span><sub>1</sub> ∧ P<span class="hidden">⇩</span><sub>2</sub> ∧ … ∧ P<span class="hidden">⇩</span><sub>n</sub> ⟶ C<span class="hidden">⇩</span><sub>1</sub> ∨ C<span class="hidden">⇩</span><sub>2</sub> ∨ … ∨ C<span class="hidden">⇩</span><sub>m</sub>›</span></span></span><span>




</span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>

----------                 ------------
P, Q ⇒ P                    P, A ⇒ P
------------               ------------
P ∧ Q ⇒ P       and        P ∧ A ⇒ P
-----------------------------------------
(P ∧ Q) ∨ (P ∧ A) ⇒ P

›</span></span></span><span>









</span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>A ⟶ B ≡ ¬ A ∨ B ›</span></span></span><span>


</span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>
       
---------------- (Axiom)
 α, Γ ⇒ α, Δ

›</span></span></span><span>

Bottom-up reading: in order to show </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>α, Γ ⇒ α, Δ›</span></span></span><span>, we need to show </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>{empty}›</span></span></span><span>
Top-down  reading: we directly have </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>α, Γ ⇒ α, Δ›</span></span></span><span>
  (Natural Deduction)

</span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>α ∧ Γ ⟶ α ∨ Δ›</span></span></span><span>





›</span></span></span><span>


</span><span class="keyword1"><span class="command"><span>lemma</span></span></span><span>
  </span><span class="quoted"><span class="quoted"><span>‹ </span><span class="main"><span>(</span></span><span class="main"><span>(</span></span><span class="free"><span>P</span></span><span> </span><span class="main"><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.implies|const"><span>⟶</span></a></span><span> </span><span class="free"><span>Q</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.implies|const"><span>⟶</span></a></span><span> </span><span class="free"><span>P</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><a class="entity_ref" href="../../HOL/HOL/HOL.html#HOL.implies|const"><span>⟶</span></a></span><span> </span><span class="free"><span>P</span></span><span>›</span></span></span><span>
  </span><span class="keyword1"><span class="command"><span>by</span></span></span><span> </span><a class="entity_ref" href="../../HOL/HOL/ISABELLE_HOME/src/Provers/blast.ML.html#HOL.blast|method"><span class="operator"><span>blast</span></span></a><span>

</span><span class="keyword1"><span class="command"><span>text</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‹


</span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>
-----------------
  P ⇒ Q, P
------------------
  ⇒ ¬ P, Q, P
-----------------------
  ⇒ (¬ P ∨ Q), P
---------------------         ----------
  ¬ (¬ P ∨ Q) ⇒ P    and      P ⇒ P
----------------------------------------
⟷   ¬ (¬ P ∨ Q) ∨ P ⇒ P
-------------------------------------------
⟷   ⇒ ¬ (¬ (¬ P ∨ Q) ∨ P), P
-------------------------------------
⟷   ⇒ (¬ (¬ (¬ P ∨ Q) ∨ P)) ∨ P
-------------------------------
⟷   ⇒ ((P ⟶ Q) ⟶ P) ⟶ P
›</span></span></span><span>

1. no loos of information -- reversibility
2. finite steps of deduction

1+2 =&gt; completeness



</span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>((P ⟶ Q) ⟶ P) ⟶ P›</span></span></span><span> : proposition, or generally call it
                            as a formula

judgement assertion
in Proposition:
  </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>Premise ⊢ Conclusion›</span></span></span><span>
Conclusion is a proposition, Premise are a list of proposition

</span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span> 

  ⊢ Conclusion  , means an assertion or judgement
                  we also call ( ⊢ Conclusion ) as a theorem
                  when the premises are empty

  Conclusion    , means nothing but just some symbols


›</span></span></span><span>

›</span></span></span><span>



</span><span class="keyword1"><span class="command"><span>text</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‹

Proposition Logic, consists of </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span> ∧, ∨, ¬, → ›</span></span></span><span>
First order-logic, Proposition Logic + </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span> ∀, ∃ ›</span></span></span><span> (quantifier)

domain

</span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span> ∃x[P(x)]  ≡  ∃x(P(x))  ≡   ∃x. P(x)  ›</span></span></span><span>  

</span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span> ∃x[P(x)] ⟷ ¬( ∀x[ ¬P(x) ] ) ›</span></span></span><span>
 exists sth, is identical to, it is not that for any x, not P

›</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>text</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‹

</span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>

  P ⊢ Q,  provability

    ⇒  , just some fancy symbol for a specific usage


[L∨] [R∨]
[∨<span class="hidden">⇩</span><sub>L</sub>] [∨<span class="hidden">⇩</span><sub>R</sub>]

[∨⇒] [⇒∨]

›</span></span></span><span>

›</span></span></span><span>


</span><span class="keyword1"><span class="command"><span>text</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‹

Instantiate v to k

</span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>

∀v[P(v)] ⟶ P(k), P(k<span class="hidden">⇩</span><sub>1</sub>), P(k<span class="hidden">⇩</span><sub>2</sub>)

›</span></span></span><span>






</span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>

 P(a), P(k), Q(a) ⇒  P(k) ∧ Q(a)
------------------------------------- (not reversible)
 ∀x[P(x)] , Q(a)  ⇒  P(k) ∧ Q(a)
------------------------------------
 ∀x[P(x)] , Q(a)  ⇒  ∀x[P(x) ∧ Q(a)]
›</span></span></span><span>


</span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>
 P(a), Q(a)   ⇒ P(k) ∧ Q(a)
------------------------------------
 P(a), Q(a)   ⇒ ∀x[P(x) ∧ Q(a)]
---------------------------------------
∀x[P(x)] , Q(a)  ⇒  ∀x[P(x) ∧ Q(a)]
›</span></span></span><span>

</span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>
  P(a), Q(a), P(k), ∀x[P(x)] ⇒ P(k) ∧ Q(a)
----------------------------------------
  P(a), Q(a), ∀x[P(x)] ⇒ P(k) ∧ Q(a)
------------------------------------------- (reversible)
 P(a), Q(a), ∀x[P(x)] ⇒ ∀x[P(x) ∧ Q(a)]
---------------------------------------
∀x[P(x)] , Q(a) ⇒  ∀x[P(x) ∧ Q(a)]
›</span></span></span><span>

when preverse the </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>∀›</span></span></span><span>, we have reversibility
but we still don't have </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>finite steps of deduction›</span></span></span><span>,
so we still don't have </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>completeness›</span></span></span><span>



›</span></span></span><span>


</span><span class="keyword1"><span class="command"><span>text</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‹

define the semantics of </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>P ⇒ Q›</span></span></span><span> by
</span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span> ⊢<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>C</sub> (P ⇒ Q)  := from P we can have Q ›</span></span></span><span>


</span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>
  from ⊢<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>C</sub> (α, β, Γ ⇒ Δ), we can have
   ⊢<span class="hidden">⇩</span><sub>S</sub><span class="hidden">⇩</span><sub>C</sub> ((α ∧ β), Γ ⇒ Δ)

›</span></span></span><span>

sound


›</span></span></span><span>


</span><span class="keyword1"><span class="command"><span>text</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‹

iff = if and only if

</span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>if P, Q›</span></span></span><span> or </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>Q, if P›</span></span></span><span> means </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>P ⟶ Q›</span></span></span><span>
</span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>only P, Q›</span></span></span><span> or </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>Q, only if P›</span></span></span><span> means </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>Q ⟶ P›</span></span></span><span>
P iff Q means </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>P ⟷ Q›</span></span></span><span>



›</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>text</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‹

define a set S, where </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>S = { s : s ∉ s }›</span></span></span><span>

question: </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span> S ∈ S ›</span></span></span><span> ?

if </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span> S ∈ S ›</span></span></span><span>, then according to the definition of S, it is wrong
if </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span> S ∉ S ›</span></span></span><span>, then according to the definition of S, </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>S ∈ S›</span></span></span><span>

when you define sth, you cannot refer the sth itself in its definition

›</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>text</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‹

</span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>G = (V, E)  ,   E = V × V   ›</span></span></span><span>

</span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span> V = {v<span class="hidden">⇩</span><sub>1</sub>, v<span class="hidden">⇩</span><sub>2</sub>, v<span class="hidden">⇩</span><sub>3</sub>, v<span class="hidden">⇩</span><sub>4</sub>}
  E = { (v<span class="hidden">⇩</span><sub>1</sub>,v<span class="hidden">⇩</span><sub>2</sub>), (v<span class="hidden">⇩</span><sub>2</sub>,v<span class="hidden">⇩</span><sub>3</sub>), (v<span class="hidden">⇩</span><sub>3</sub>,v<span class="hidden">⇩</span><sub>4</sub>), (v<span class="hidden">⇩</span><sub>1</sub>,v<span class="hidden">⇩</span><sub>4</sub>) } ›</span></span></span><span>

</span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span> 
  --------------
  |            |
  1 ---- 2 --- 3 --- 4
  |                  |
  --------------------
 ›</span></span></span><span>


</span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>E = V × V›</span></span></span><span>  called as complete graph (clique)



</span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>E = { (1,2), (2,1), (1,3), (3,1), (3,2), (2,3), (3,4), (4,3) } ›</span></span></span><span>

undirected edge: </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>(u,v) ∈ E &lt;--&gt; (v,u) ∈ E›</span></span></span><span>

Representation of Graph:

1. Adjacency matrix, is a data structure storing E the set of edge

</span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span> bool edge[N][N] ›</span></span></span><span>
where </span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span> (u,v) ∈ E ⟷ edge[u][v] is true ›</span></span></span><span>

2. an array of edges
   {src: int, target: int}[M] ,  where M is the number of edges


</span><span class="antiquoted"><span class="raw_text"><span class="operator"><span>‹</span></span><span>
Input: an array of edges, of length M,
Output: a boolean giving whether the graph G contains a clique of 4 elements

1. construct the adjacency matrix

let adjmat = an N×N boolean array of all false elements, where N is the number of vertices.

for (v,u) in edges {
  adjmat[v][u] = true
  adjmat[u][v] = true
}

2. we look for the clique by enumerating the potential two edges of the clique

for (v,u) in edges {
for (w,x) in edges {
  if v≠w and v≠x and u≠w and u≠x
     and adjmat[v][w] and adjmat[u][x] and adjmat[v][x] and adjmat[w][u]
  then output the clique exists
  else continue
} }
output the clique doens't exist



‹
v    u
| x  |
w    x
›


›</span></span></span><span>

›</span></span></span><span>





</span><span class="keyword2"><span class="keyword"><span>end</span></span></span></pre>
</body>

</html>